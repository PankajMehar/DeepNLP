
Recently deep learning has emerged as a useful technique for data classiﬁcation as well
as ﬁnding feature representations. We consider the scenario of multi-class classiﬁca-
tion. A deep neural network maps each feature vector to one of the class labels by the
connection of nodes in a multi-layer structure. Between two adjacent layers a weight
matrix maps the inputs (values in the previous layer) to the outputs (values in the current
layer). Assume the training set includes (yi, xi), i = 1, . . . , l, where xi ∈ (cid:60)n0 is the
feature vector and yi ∈ (cid:60)K is the label vector. If xi is associated with label k, then
yi = [0, . . . , 0
, 1, 0, . . . , 0]T ∈ (cid:60)K,
(cid:124) (cid:123)(cid:122) (cid:125)
k−1
where K is the number of classes and {1, . . . , K} are possible labels. After collecting
all weights and biases as the model vector θ and having a loss function ξ(θ; x, y), a
neural-network problem can be written as the following optimization problem.
where
min
f (θ),
f (θ) =
2C
θT θ +
l(cid:88)
i=1
ξ(θ; xi, yi).
(1)
(2)
The regularization term θT θ/2 avoids overﬁtting the training data, while the parameter
C balances the regularization term and the loss term. The function f (θ) is non-convex
because of the connection between weights in different layers. This non-convexity and
the large number of weights have caused tremendous difﬁculties in training large-scale
deep neural networks. To apply an optimization algorithm for solving (2), the calcula-
tion of function, gradient, and Hessian can be expensive. Currently, stochastic gradient
(SG) methods are the most commonly used way to train deep neural networks (e.g., Bot-
tou, 1991; LeCun et al., 1998b; Bottou, 2010; Zinkevich et al., 2010; Dean et al., 2012;
Moritz et al., 2015). In particular, some expensive operations can be efﬁciently con-
ducted in GPU environments (e.g., Ciresan et al., 2010; Krizhevsky et al., 2012; Hinton
et al., 2012). Besides stochastic gradient methods, some works such as Martens (2010);
Kiros (2013); He et al. (2016) have considered a Newton method of using Hessian infor-
mation. Other optimization methods such as ADMM have also been considered (Taylor
et al., 2016).
When the model or the data set is large, distributed training is needed. Following
the design of the objective function in (2), we note it is easy to achieve data paral-
lelism: if data instances are stored in different computing nodes, then each machine can
calculate the local sum of training losses independently.1 However, achieving model
parallelism is more difﬁcult because of the complicated structure of deep neural net-
works. In this work, by considering that the model is distributedly stored we propose a
novel distributed Newton method for deep learning. By variable and feature-wise data
partitions, and some careful designs, we are able to explicitly use the Jacobian matrix
for matrix-vector products in the Newton method. Some techniques are incorporated
to reduce the running time as well as the memory consumption. First, to reduce the
communication cost, we propose a diagonalization method such that an approximate
Newton direction can be obtained without communication between machines. Second,
we consider subsampled Gauss-Newton matrices for reducing the running time as well
as the communication cost. Third, to reduce the synchronization cost, we terminate the
process of ﬁnding an approximate Newton direction even though some nodes have not
ﬁnished their tasks.
To be focused, among the various types of neural networks, we consider the stan-
dard feedforward networks in this work. We do not consider other types such as the
convolution networks that are popular in computer vision.
This work is organized as follows. Section 2 introduces existing Hessian-free New-
ton methods for deep learning. In Section 3, we propose a distributed Newton method
for training neural networks. We then develop novel techniques in Section 4 to reduce
running time and memory consumption. In Section 5 we analyze the cost of the pro-
1Training deep neural networks with data parallelism has been considered in SG, Newton and other
optimization methods. For example, He et al. (2015) implement a parallel Newton method by letting
each node store a subset of instances.
posed algorithm. Additional implementation techniques are given in Section 6. Then
Section 7 reviews some existing optimization methods, while experiments in Section 8
demonstrate the effectiveness of the proposed method. Programs used for experiments
in this paper are available at
http://www.csie.ntu.edu.tw/˜cjlin/papers/dnn.
Supplementary materials including a list of symbols and additional experiments can be
found at the same web address.
2 Hessian-free Newton Method for Deep Learning
In this section, we begin with introducing feedforward neural networks and then review
existing Hessian-free Newton methods to solve the optimization problem.
2.1 Feedforward Networks
A multi-layer neural network maps each feature vector to a class vector via the con-
nection of nodes. There is a weight vector between two adjacent layers to map the
input vector (the previous layer) to the output vector (the current layer). The network
in Figure 1 is an example. Let nm denote the number of nodes at the mth layer. We
use n0(input)-n1- . . . -nL(output) to represent the structure of the network.3 The weight
2This ﬁgure is modiﬁed from the example at http://www.texample.net/tikz/
examples/neural-network.
3Note that n0 is the number of features and nL = K is the number of classes.
A0
B0
C0
A1
B1
Figure 1: An example of feedforward neural networks.2
matrix W m and the bias vector bm at the mth layer are

wm
1nm
2nm
wm
...
···
···
...
··· wm

bm
bm
...
bm
nm
and
bm =
wm
nm−11 wm
nm−12
nm−1nm
nm−1×nm

wm
11
wm
21
...
wm
12
wm
22
...
W m =
Let
A2
B2
C2

nm×1
s0,i = z0,i = xi
be the feature vector for the ith instance, and sm,i and zm,i denote vectors of the ith
instance at the mth layer, respectively. We can use
sm,i = (W m)T zm−1,i + bm, m = 1, . . . , L, i = 1, . . . , l
zm,i
j = σ(sm,i
), j = 1, . . . , nm, m = 1, . . . , L, i = 1, . . . , l
(3)
to derive the value of the next layer, where σ(·) is the activation function.
If W m’s columns are concatenated to the following vector
(cid:20)
wm =
wm
11
. . . wm
nm−11 wm
12
. . . wm
nm−12
. . . wm
1nm . . . wm
nm−1nm
(cid:21)T
then we can deﬁne
θ =

w1
b1
...
wL
bL

as the weight vector of a whole deep neural network. The total number of parameters is
L(cid:88)
n =
(nm−1 × nm + nm) .
m=1
Because zL,i is the output vector of the ith data, by a loss function to compare it with the
label vector yi, a neural network solves the following regularized optimization problem
where
min
f (θ),
f (θ) =
2C
θT θ +
l(cid:88)
i=1
ξ(zL,i; yi),
(4)
C > 0 is a regularization parameter, and ξ(zL,i; yi) is a convex function of zL,i. Note
that we rewrite the loss function ξ(θ; xi, yi) in (2) as ξ(zL,i; yi) because zL,i is decided
by θ and xi. In this work, we consider the following loss function
ξ(zL,i; yi) = ||zL,i − yi||2.
The gradient of f (θ) is
∇f (θ) =
θ +
l(cid:88)
i=1
(J i)T∇zL,iξ(zL,i; yi),
(5)
(6)
where

J i =
∂zL,i
∂θ1
...
∂zL,i
nL
∂θ1
···
...
···
∂zL,i
∂θn
...
∂zL,i
nL
∂θn

nL×n
, i = 1, . . . , l,
(7)
is the Jacobian of zL,i, which is a function of θ. The Hessian matrix of f (θ) is
∇2f (θ) =
I +
(J i)T BiJ i
l(cid:88)
∂ξ(zL,i; yi)
i=1
j=1
∂zL,i
where I is the identity matrix and
Bi
ts =
∂2ξ(zL,i; yi)
t ∂zL,i
∂zL,i
, t = 1, . . . , nL, s = 1, . . . , nL.
From now on for simplicity we let
ξi ≡ ξi(zL,i; yi).
2.2 Hessian-free Newton Method
l(cid:88)
nL(cid:88)
i=1

∂2zL,i
∂θ1∂θ1
...
∂2zL,i
∂θn∂θ1
···
...
···
∂2zL,i
∂θ1∂θn
...
∂2zL,i
∂θn∂θn
 ,
(8)
(9)
For the standard Newton methods, at the kth iteration, we ﬁnd a direction dk minimizing
the following second-order approximation of the function value:
min
dT H kd + ∇f (θk)T d,
(10)
where H k = ∇2f (θk) is the Hessian matrix of f (θk). To solve (10), ﬁrst we calculate
the gradient vector by a backward process based on (3) through the following equations:
), i = 1, . . . , l, m = 1, . . . , L, j = 1, . . . , nm
wm
tj , i = 1, . . . , l, m = 1, . . . , L, t = 1, . . . , nm−1
(11)
(12)
∂ξi
∂zm,i
nm(cid:88)
j=1
∂ξi
∂sm,i
∂ξi
∂zm−1,i
∂f
∂wm
tj
σ(cid:48)(sm,i
∂ξi
∂sm,i
l(cid:88)
i=1
wm
tj +
zm−1,i
∂ξi
∂sm,i
, m = 1, . . . , L, j = 1, . . . , nm, t = 1, . . . , nm−1
l(cid:88)
i=1
∂ξi
∂sm,i
∂f
∂bm
bm
j +
, m = 1, . . . , L, j = 1, . . . , nm.
(13)
(14)
Note that formally the summation in (13) should be
l(cid:88)
l(cid:88)
i=1
i(cid:48)=1
zm−1,i(cid:48)
∂ξi
∂sm,i(cid:48)
but it is simpliﬁed because ξi is associated with only sm,i
If H k is positive deﬁnite, then (10) is equivalent to solving the following linear
system:
H kd = −∇f (θk).
(15)
Unfortunately, for the optimization problem (10), it is well known that the objective
function may be non-convex and therefore H k is not guaranteed to be positive deﬁnite.
Following Schraudolph (2002), we can use the Gauss-Newton matrix as an approxima-
tion of the Hessian. That is, we remove the last term in (8) and obtain the following
positive-deﬁnite matrix.
G =
I +
l(cid:88)
(J i)T BiJ i.
i=1
(16)
Note that from (9), each Bi, i = 1, . . . , l is positive semi-deﬁnite if we require that
ξ(zL,i; yi) is a convex function of zL,i. Therefore, instead of using (15), we solve the
following linear system to ﬁnd a dk for deep neural networks.
(Gk + λkI)d = −∇f (θk),
(17)
where Gk is the Gauss-Newton matrix at the kth iteration and we add a term λkI be-
cause of considering the Levenberg-Marquardt method (see details in Section 4.5).
For deep neural networks, because the total number of weights may be very large, it
is hard to store the Gauss-Newton matrix. Therefore, Hessian-free algorithms have been
applied to solve (17). Examples include Martens (2010); Ngiam et al. (2011). Specif-
ically, conjugate gradient (CG) methods are often used so that a sequence of Gauss-
Newton matrix vector products are conducted. Martens (2010); Wang et al. (2015) use
R-operator (Pearlmutter, 1994) to implement the product without storing the Gauss-
Newton matrix.
Because the use of R operators for the Newton method is not the focus of this work,
we leave some detailed discussion in Sections II–III in supplementary materials.
3 Distributed Training by Variable Partition
The main computational bottleneck in a Hessian-free Newton method is the sequence
of matrix-vector products in the CG procedure. To reduce the running time, parallel
matrix-vector multiplications should be conducted. However, the R operator discussed
in Section 2 and Section II in supplementary materials is inherently sequential.
In
a forward process results in the current layer must be ﬁnished before the next. In this
10
section, we propose an effective distributed algorithm for training deep neural networks.
3.1 Variable Partition
Instead of using the R operator to calculate the matrix-vector product, we consider the
whole Jacobian matrix and directly use the Gauss-Newton matrix in (16) for the matrix-
vector products in the CG procedure. This setting is possible because of the following
reasons.
1. A distributed environment is used.
2. With some techniques we do not need to explicitly store every element of the Jaco-
bian matrix.
Details will be described in the rest of this paper. To begin we split each J i to P
partitions
(cid:20)
J i =
(cid:21)
··· J i
J i
Because the number of columns in J i is the same as the number of variables in the
optimization problem, essentially we partition the variables to P subsets. Speciﬁcally,
we split neurons in each layer to several groups. Then weights connecting one group of
the current layer to one group of the next layer form a subset of our variable partition.
For example, assume we have a 150-200-30 neural network in Figure 2. By splitting the
three layers to 3, 2, 3 groups, we have a total number of partitions P = 12. The partition
(A0, A1) in Figure 2 is responsible for a 50 × 100 sub-matrix of W 1. In addition, we
distribute the variable bm to partitions corresponding to the ﬁrst neuron sub-group of the
11
A0
B0
C0
A0,A1
A0,B1
B0,A1
B0,B1
C0,A1
C0,B1
A1
B1
A1,A2
A1,B2
A1,C2
B1,A2
B1,B2
B1,C2
A2
B2
C2
Figure 2: An example of splitting variables in Figure 1 to 12 partitions by a split struc-
ture of 3-2-3. Each circle corresponds to a neuron sub-group in a layer, while each
square is a partition corresponding to weights connecting one neuron sub-group in a
layer to one neuron sub-group in the next layer.
mth layer. For example, the 200 variables of b1 is split to 100 in the partition (A0, A1)
and 100 in the partition (A0, B1).
By the variable partition, we achieve model parallelism. Further, because z0,i = xi
from (2.1), our data points are split in a feature-wise way to nodes corresponding to
partitions between layers 0 and 1. Therefore, we have data parallelism.
With the variable partition, the second term in the Gauss-Newton matrix (16) for the
12
ith instance can be represented as

(J i
1)T BiJ i
(J i
P )T BiJ i
 .
···
...
···
(J i
1)T BiJ i
(J i
P )T BiJ i
(J i)T BiJ i =
In the CG procedure to solve (17), the product between the Gauss-Newton matrix and
a vector v is
Gv =

(cid:80)l
(cid:80)l
1)T Bi((cid:80)P
P )T Bi((cid:80)P
...
i=1(J i
p=1 J i
pvp) + 1
C v1
i=1(J i
p=1 J i
pvp) + 1
C vP

(18)

v1
...
vP
 , where v =
2
(cid:17)
if t = s,
0 otherwise.
is partitioned according to our variable split. From (9) and the loss function deﬁned in
(5),
Bi
ts =
∂2(cid:16)(cid:80)nL
j − yi
j=1(zL,i
∂zL,i
t ∂zL,i
j)2(cid:17)
(cid:16)
2(zL,i
t − yi
t)
∂zL,i
However, after the variable partition, each J i may still be a huge matrix. The total
space for storing J i
p, ∀i is roughly
nL × n
× l.
If l, the number of data instances, is so large such that
l × nL
> n,
than storing J i
p, ∀i requires more space than the n× n Gauss-Newton matrix. To reduce
the memory consumption, we will propose effective techniques in Sections 3.3, 4.3, and
6.1.
13
With the variable partition, function, gradient, and Jacobian calculations become
complicated. We discuss details in Sections 3.2 and 3.3.
3.2 Distributed Function Evaluation
From (3) we know how to evaluate the function value in a single machine, but the im-
plementation in a distributed environment is not trivial. Here we check the details from
the perspective of an individual partition. Consider a partition that involves neurons in
sets Tm−1 and Tm from layers m − 1 and m, respectively. Thus
Tm−1 ⊂ {1, . . . , nm−1} and Tm ⊂ {1, . . . , nm}.
Because (3) is a forward process, we assume that
sm−1,i
, i = 1, . . . , l, ∀t ∈ Tm−1
are available at the current partition. The goal is to generate
, i = 1, . . . , l, ∀j ∈ Tm
sm,i
and pass them to partitions between layers m and m + 1. To begin, we calculate
zm−1,i
= σ(sm−1,i
), i = 1, . . . , l and t ∈ Tm−1.
(19)
Then, from (3), the following local values can be calculated for i = 1, . . . , l, j ∈ Tm
tj zm−1,i
wm
+ bm
if Tm−1 is the ﬁrst neuron sub-group of layer m − 1,
tj zm−1,i
wm
otherwise.
(20)
14

(cid:80)
(cid:80)
t∈Tm−1
t∈Tm−1
After the local sum in (20) is obtained, we must sum up values in partitions between
layers m − 1 and m.
(cid:88)
(cid:16)
sm,i
j =
Tm−1∈Pm−1
(cid:17)
local sum in (20)
(21)
where i = 1, . . . , l, j ∈ Tm, and
Pm−1 = {Tm−1 | Tm−1 is any sub-group of neurons at layer m − 1}.
The resulting sm,i
values should be broadcasted to partitions between layers m and
m + 1 that correspond to the neuron subset Tm. We explain details of (21) and the
broadcast operation in Section 3.2.1.
3.2.1 Allreduce and Broadcast Operations
The goal of (21) is to generate and broadcast sm,i
values to some partitions between
layers m and m + 1, so a reduce operation seems to be sufﬁcient. However, we will
explain in Section 3.3 that for the Jacobian evaluation and then the product between
Gauss-Newton matrix and a vector, the partitions between layers m − 1 and m corre-
sponding to Tm also need sm,i
for calculating
zm,i
j = σ(sm,i
), i = 1, . . . , l, j ∈ Tm.
(22)
To this end, we consider an allreduce operation so that not only are values reduced from
some partitions between layers m − 1 and m, but also the result is broadcasted to them.
After this is done, we make the same result sm,i
available in partitions between layers
m and m + 1 by choosing the partition corresponding to the ﬁrst neuron sub-group of
layer m − 1 to conduct a broadcast operation. Note that for partitions between layers
L − 1 and L (i.e., the last layer), a broadcast operation is not needed.
15
Consider the example in Figure 2. For partitions (A1, A2), (A1, B2), and (A1, C2),
all of them must get s1,i
j , j ∈ A1 calculated via (21):
(cid:88)
(cid:123)(cid:122)
(cid:124)
(cid:88)
(cid:124)
t + b1
(cid:123)(cid:122)
tjz0,i
t∈B0
t∈A0
(cid:125)
w1
(A0,A1)
(cid:125)
s1,i
j =
(cid:88)
(cid:124)
t∈C0
w1
(cid:123)(cid:122)
(cid:125)
(B0,A1)
(C0,A1)
w1
tjz0,i
tjz0,i
(23)
The three local sums are available at partitions (A0, A1), (B0, A1) and (C0, A1) re-
j , j ∈ A1 are available
spectively. We ﬁrst conduct an allreduce operation so that s1,i
at partitions (A0, A1), (B0, A1), and (C0, A1). Then we choose (A0, A1) to broadcast
values to (A1, A2), (A1, B2), and (A1, C2).
Depending on the system conﬁgurations, suitable ways can be considered for im-
plementing the allreduce and the broadcast operations (Thakur et al., 2005). In Section
IV of supplementary materials we give details of our implementation.
To derive the loss value, we need one ﬁnal reduce operation. For the example in
, j ∈ A2, B2, C2 respectively available in partitions
Figure 2, in the end we have z2,i
(A1, A2), (A1, B2), and (A1, C2).
We then need the following reduce operation
||z2,i − yi||2 =
j − yi
(z2,i
j)2 +
(cid:88)
j∈A2
(cid:88)
j∈B2
j − yi
(z2,i
j)2 +
(cid:88)
j∈C2
j − yi
(z2,i
j)2
(24)
and let (A1, A2) have the loss term in the objective value.
We have discussed the calculation of the loss term in the objective value, but we
also need to obtain the regularization term θT θ/2. One possible setting is that before
the loss-term calculation we run a reduce operation to sum up all local regularization
terms. For example, in one partition corresponding to neuron subgroups Tm−1 at layer
16
m − 1 and Tm at layer m, the local value is(cid:88)
(cid:88)
t∈Tm−1
j∈Tm
(wm
tj )2.
(25)
On the other hand, we can embed the calculation into the forward process for obtaining
the loss term. The idea is that we append the local regularization term in (25) to the
vector in (20) for an allreduce operation in (21). The cost is negligible because we only
increase the length of each vector by one. After the allreduce operation, we broadcast
the resulting vector to partitions between layers m and m + 1 that corresponding to
the neuron subgroup Tm. We cannot let each partition collect the broadcasted value for
subsequent allreduce operations because regularization terms in previous layers would
be calculated several times. To this end, we allow only the partition corresponding to
Tm in layer m and the ﬁrst neuron subgroup in layer m + 1 to collect the value and
include it with the local regularization term for the subsequent allreduce operation. By
continuing the forward process, in the end we get the whole regularization term.
We use Figure 2 to give an illustration. The allreduce operation in (23) now also
calculates (cid:88)
(cid:124)
t∈A0
(cid:88)
j∈A1
(w1
tj)2 +
(cid:123)(cid:122)
(A0,A1)
(cid:88)
j∈A1
(cid:88)
(cid:124)
t∈B0
(b1
j )2
(cid:125)
(cid:88)
(cid:123)(cid:122)
j∈A1
(cid:88)
(cid:124)
t∈C0
(cid:88)
(cid:123)(cid:122)
j∈A1
(cid:125)
(cid:125)
(B0,A1)
(C0,A1)
(w1
tj)2
(w1
tj)2
(26)
The resulting value is broadcasted to
(A1, A2), (A1, B2), and (A1, C2).
Then only (A1, A2) collects the value and generate the following local sum:
(26) +
In the end we have
(cid:88)
(cid:88)
t∈A1
j∈A2
(cid:88)
j∈A2
(b2
j )2.
(w2
tj)2 +
17
1. (A1, A2) contains regularization terms from
(A0, A1), (B0, A1), (C0, A1), (A1, A2), (A0, B1), (B0, B1), (C0, B1), (B1, A2).
2. (A1, B2) contains regularization terms from
(A1, B2), (B1, B2).
3. (A1, C2) contains regularization terms from
(A1, C2), (B1, C2).
We can then extend the reduce operation in (24) to generate the ﬁnal value of the regu-
larization term.
3.3 Distributed Jacobian Calculation
From (7) and similar to the way of calculating the gradient in (11)-(14), the Jacobian
matrix satisﬁes the following properties.
∂zL,i
∂wm
tj
∂zL,i
∂bm
∂zL,i
∂sm,i
∂zL,i
∂sm,i
∂sm,i
∂wm
tj
∂sm,i
∂bm
(28)
(29)
where i = 1, . . . , l, u = 1, . . . , nL, m = 1, . . . , L, j = 1, . . . , nm, and t = 1, . . . , nm−1.
However, these formulations do not reveal how they are calculated in a distributed set-
ting. Similar to Section 3.2, we check details from the perspective of any variable par-
tition. Assume the current partition involves neurons in sets Tm−1 and Tm from layers
m − 1 and m, respectively. Then we aim to obtain the following Jacobian components.
∂zL,i
∂wm
tj
and ∂zL,i
∂bm
, ∀t ∈ Tm−1, ∀j ∈ Tm, u = 1, . . . , nL, i = 1, . . . , l.
18
Before showing how to calculate them, we ﬁrst get from (3) that
∂zL,i
∂sm,i
∂sm,i
∂wm
tj
∂zL,i
∂zm,i
= zm−1,i
∂zm,i
∂sm,i
∂zL,i
∂zm,i
σ(cid:48)(sm,i
),
and
∂sm,i
∂bm
= 1,
∂zL,i
∂zL,i
if j = u,
0 otherwise.
(30)
(31)
(32)
1


From (28)-(32), the elements for the local Jacobian matrix can be derived by
and
∂zL,i
∂wm
tj
∂zL,i
∂bm
∂zL,i
∂zm,i
∂zL,i
∂zm,i
∂zm,i
∂sm,i
∂zm,i
∂sm,i
∂sm,i
∂wm
tj
∂sm,i
∂bm
σ(cid:48)(sm,i
)zm−1,i
if m < L,
∂zL,i
∂zm,i
σ(cid:48)(sL,i
u )zL−1,i
if m = L, j = u,
(33)
if m = L, j (cid:54)= u,
σ(cid:48)(sm,i
if m < L,
∂zL,i
∂zm,i
σ(cid:48)(sL,i
u )
if m = L, j = u,
if m = L, j (cid:54)= u,
(34)
where u = 1, . . . , nL, i = 1, . . . , l, t ∈ Tm−1, and j ∈ Tm.
We discuss how to have values in the right-hand side of (33) and (34) available at
the current computing node. From (19), we have
zm−1,i
, ∀i = 1, . . . , l, ∀t ∈ Tm−1
available in the forward process of calculating the function value. Further, in (21)-(22)
to obtain zm,i
for layers m and m+1, we use an allreduce operation rather than a reduce
operation so that
, ∀i = 1, . . . , l, ∀j ∈ Tm
sm,i
19
are available at the current partition between layers m − 1 and m. Therefore, σ(cid:48)(sm,i
in (33)-(34) can be obtained. The remaining issue is to generate ∂zL,i
u /∂zm,i
. We will
show that they can be obtained by a backward process. Because the discussion assumes
that currently we are at a partition between layers m − 1 and m, we show details of
and dispatching them to partitions between m− 2 and m− 1.
generating ∂zL,i
u /∂zm−1,i
From (3) and (30), ∂zL,i
can be calculated by
u /zm−1,i
nm(cid:88)
j=1
∂zL,i
∂zm−1,i
∂zL,i
∂sm,i
∂sm,i
∂zm−1,i
nm(cid:88)
j=1
Therefore, we consider a backward process of using ∂zL,i
In a distributed system, from (32) and (35),
∂zL,i
∂zm,i
σ(cid:48)(sm,i
)wm
tj .
(35)
u /∂zm,i
to generate ∂zL,i
u /∂zm−1,i
(cid:80)

(cid:80)
(cid:80)
∂zL,i
∂zm−1,i
Tm∈Pm
j∈Tm
∂zL,i
∂zm,i
σ(cid:48)(sm,i
)wm
tj
if m < L,
(36)
Tm∈Pm
σ(cid:48)(sL,i
u )wL
tu
if m = L,
where i = 1, . . . , l, u = 1, . . . , nL, t ∈ Tm−1, and
Pm = {Tm | Tm is any sub-group of neurons at layer m}.
(37)
Clearly, each partition calculates the local sum over j ∈ Tm. Then a reduce operation
is needed to sum up values in all corresponding partitions between layers m − 1 and
m. Subsequently, we discuss details of how to transfer data to partitions between layers
m − 2 and m − 1.
Consider the example in Figure 2. The partition (A0, A1) must get
, t ∈ A1, u = 1, . . . , nL, i = 1, . . . , l.
∂zL,i
∂z1,i
From (36),
∂zL,i
∂z1,i
(cid:88)
(cid:124)
j∈A2
(cid:88)
(cid:124)
j∈B2
(cid:125)
σ(cid:48)(s2,i
j )w2
tj
∂zL,i
∂z2,i
(cid:123)(cid:122)
(A1,A2)
(cid:88)
(cid:124)
j∈C2
(cid:125)
σ(cid:48)(s2,i
j )w2
tj
∂zL,i
∂z2,i
(cid:123)(cid:122)
(A1,B2)
20
σ(cid:48)(s2,i
j )w2
tj
(38)
∂zL,i
∂z2,i
(cid:123)(cid:122)
(A1,C2)
(cid:125)
Note that these three sums are available at partitions (A1, A2), (A1, B2), and (A1, C2),
respectively. Therefore, (38) is a reduce operation. Further, values obtained in (38) are
needed in partitions not only (A0, A1) but also (B0, A1) and (C0, A1). Therefore, we
need a broadcast operation so values can be available in the corresponding partitions.
For details of implementing reduce and broadcast operations, see Section IV of
supplementary materials. Algorithm 2 summarizes the backward process to calculate
∂zL,i
u /∂zm,i
3.3.1 Memory Requirement
We have mentioned in Section 3.1 that storing all elements in the Jacobian matrix may
not be viable. In the distributing setting, if we store all Jacobian elements corresponding
to the current partition, then
|Tm−1| × |Tm| × nL × l
(39)
space is needed. We propose a technique to save space by noting that (28) can be written
as the product of two terms. From (30)-(31), the ﬁrst term is related to only Tm, while
the second is related to only Tm−1:
∂zL,i
∂wm
tj
= [
∂zL,i
∂sm,i
][
∂sm,i
∂wm
tj
] = [
∂zL,i
∂zm,i
σ(cid:48)(sm,i
)][zm−1,i
].
(40)
They are available in our earlier calculation. Speciﬁcally, we allocate space to receive
∂zL,i
u /∂zm,i
from previous layers. After obtaining the values, we replace them with
∂zL,i
∂zm,i
σ(cid:48)(sm,i
(41)
for the future use. Therefore, the Jacobian matrix is not explicitly stored. Instead, we
use the two terms in (40) for the product between the Gauss-Newton matrix and a vector
21
in the CG procedure. See details in Section 4.2. Note that we also need to calculate and
, ∀t ∈
store the local sum before the reduce operation in (36) for getting ∂zL,i
Tm−1, ∀u, ∀i. Therefore, the memory consumption is proportional to
u /∂zm−1,i
l × nL × (|Tm−1| + |Tm|).
This setting signiﬁcantly reduces the memory consumption of directly storing the Jaco-
bian matrix in (39).
3.3.2 Sigmoid Activation Function
In the discussion so far, we consider a general differentiable activation function σ(sm,i
).
In the implementation in this paper, we consider the sigmoid function except the output

j = σ(sm,i
zm,i
) =
−s
1+e
m,i
if m < L,
sm,i
if m = L.
(42)
layer:
Then,

(cid:18)
σ(cid:48)(sm,i
) =
−s
m,i
−s
m,i
1+e
(cid:19)2 = zm,i
(1 − zm,i
if m < L,
if m = L.
and (33)-(34) become

∂zL,i
∂wm
tj
zm,i
(1 − zm,i
)zm−1,i
∂zL,i
∂bm
∂zL,i
∂zm,i
zL−1,i
0,

zm,i
(1 − zm,i
if m < L,
∂zL,i
∂zm,i
if m = L, j = u,
if m = L, j (cid:54)= u,
where u = 1, . . . , nL, i = 1, . . . , l, t ∈ Tm−1, and j ∈ Tm.
22
3.4 Distributed Gradient Calculation
For the gradient calculation, from (4),
∂f
∂wm
tj
wm
tj +
∂ξi
∂wm
tj
wm
tj +
l(cid:88)
i=1
l(cid:88)
nL(cid:88)
i=1
u=1
∂ξi
∂zL,i
∂zL,i
∂wm
tj
(43)
where ∂zL,i
u /∂wm
tj , ∀t, ∀j are components of the Jacobian matrix; see also the matrix
form in (6). From (33), we have known how to calculate ∂zL,i
u /∂wm
tj . Therefore, if
∂ξi/∂zL,i
is passed to the current partition, we can easily obtain the gradient vector via
(43). This can be ﬁnished in the same backward process of calculating the Jacobian
matrix.
On the other hand, in the technique that will be introduced in Section 4.3, we only
consider a subset of instances to construct the Jacobian matrix as well as the Gauss-
Newton matrix. That is, by selecting a subset S ⊂ {1, . . . , l}, then only J i,∀i ∈ S are
considered. Thus we do not have all the needed ∂zL,i
u /∂wm
tj for (43). In this situation,
we can separately consider a backward process to calculate the gradient vector. From a
derivation similar to (33),
∂ξi
∂wm
tj
∂ξi
∂zm,i
σ(cid:48)(sm,i
)zm−1,i
, m = 1, . . . , L.
(44)
to be like ∂zL,i
By considering ∂ξi/∂zm,i
in (36), we can apply the same back-
ward process so that each partition between layers m − 2 and m − 1 must wait for
∂ξi/∂zm−1,i
from partitions between layers m − 1 and m:
u /∂zm,i
(cid:88)
(cid:88)
Tm∈Pm
j∈Tm
∂ξi
∂zm−1,i
σ(cid:48)(sm,i
)wm
tj ,
∂ξi
∂zm,i
(45)
where i = 1, . . . , l, t ∈ Tm−1, and Pm is deﬁned in (37). For the initial ∂ξi/∂zL,i
in the
23
backward process, from the loss function deﬁned in (5),
= 2 ×(cid:16)
∂ξi
∂zL,i
(cid:17)
j − yi
zL,i
From (43), a difference from the Jacobian calculation is that here we obtain a sum
over all instances i. Earlier we separately maintain terms related to Tm−1 and Tm to
avoid storing all Jacobian elements. With the summation over i, we can afford to store
∂f /∂wm
tj and ∂f /∂bm
j , ∀t ∈ Tm−1, ∀j ∈ Tm.
4 Techniques to Reduce Computational, Communica-
tion, and Synchronization Cost
In this section we propose some novel techniques to make the distributed Newton
method a practical approach for deep neural networks.
4.1 Diagonal Gauss-Newton Matrix Approximation
In (18) for the Gauss-Newton matrix-vector products in the CG procedure, we notice
that the communication occurs for reducing P vectors
1v1, . . . , J i
J i
P vP ,
each with size O(nL), and then broadcasting the sum to all nodes. To avoid the high
communication cost in some distributed systems, we may consider the diagonal blocks
24
of the Gauss-Newton matrix as its approximation:
i=1(J i
1)T BiJ i
ˆG =
I +
...
(cid:80)l
i=1(J i
P )T BiJ i
Then (17) becomes P independent linear systems
(cid:80)l

l(cid:88)
i=1
(J i
1)T BiJ i
1 +
l(cid:88)
(J i
P )T BiJ i
P +
i=1
I + λkI)dk
1 = −gk
1,
...
I + λkI)dk
P = −gk
P ,
The matrix-vector product becomes
where gk
1, . . . , gk
P are local components of the gradient:
 .

gk
...
gk
∇f (θk) =

(cid:80)l
(cid:80)l
i=1(J i
1)T BiJ i
1v1 + 1
C v1
Gv ≈ ˆGv =
...
i=1(J i
P )T BiJ i
P vP + 1
C vP
 ,
 .
(49)
(50)
(51)
in which each (Gv)p can be calculated using only local information because we have
independent linear systems. For the CG procedure at any partition, it is terminated if
the following relative stopping condition holds
||1
(J i
p)T BiJ i
pvp + (
+ λk)vp + gk
p|| ≤ σ||gk
p||
(52)
or the number of CG iterations reaches a pre-speciﬁed limit. Here σ is a pre-speciﬁed
tolerance. Unfortunately, partitions may ﬁnish their CG procedures at different time, a
25
l(cid:88)
i=1
situation that results in signiﬁcant waiting time. To address this synchronization cost,
we propose some novel techniques in Section 4.4.
Some past works have considered using diagonal blocks as the approximation of the
Hessian. For logistic regression, Bian et al. (2013) consider diagonal elements of the
Hessian to solve several one-variable sub-problems in parallel. Mahajan et al. (2017)
study a more general setting in which using diagonal blocks is a special case.
4.2 Product Between Gauss-Newton Matrix and a Vector
In the CG procedure the main computational task is the matrix-vector product. We
present techniques for the efﬁcient calculation. From (51), for the pth partition, the
product between the local diagonal block of the Gauss-Newton matrix and a vector vp
takes the following form.
(J i
p)T BiJ i
pvp.
Assume the pth partition involves neuron sub-groups Tm−1 and Tm respectively in layers
j , ∀j ∈ Tm.
m− 1 and m, and this partition is not responsible to handle the bias term bm
Then
p ∈ RnL×(|Tm−1|×|Tm|) and vp ∈ R(|Tm−1|×|Tm|)×1.
J i
Let mat(vp) ∈ R|Tm−1|×|Tm| be the matrix representation of vp. From (40), the uth
component of (J i
pvp)u is
(cid:88)
(cid:88)
∂zL,i
∂wm
tj
(mat(vp))tj =
t∈Tm−1
j∈Tm
zm−1,i
(mat(vp))tj.
(53)
∂zL,i
∂sm,i
(cid:88)
(cid:88)
t∈Tm−1
j∈Tm
26
j∈Tm
While calculating
 .
zm−1,i
(mat(vp))tj
(cid:88)
 (cid:88)
t∈Tm−1
∂zL,i
∂sm,i
(cid:88)
t∈Tm−1
zm−1,i
(vp)tj, ∀j ∈ Tm
A direct calculation of the above value requires O(|Tm−1| × |Tm|) operations. Thus to
get all u = 1, . . . , nL components, the total computational cost is proportional to
nL × |Tm−1| × |Tm|.
We discuss a technique to reduce the cost by rewriting (53) as
still needs O(|Tm−1| × |Tm|) cost, we notice that these values are independent of u.
pvp)u, ∀u. Therefore, the total
That is, they can be stored and reused in calculating (J i
computational cost is signiﬁcantly reduced to
|Tm−1| × |Tm| + nL × |Tm|.
(54)
The procedure of deriving (J i
p)T (BiJ i
pvp) is similar. Assume
¯v = BiJ i
pvp ∈ RnL×1.
From (40),
Because
p)T ¯v(cid:1)
mat(cid:0)(J i
tj
nL(cid:88)
nL(cid:88)
u=1
u=1
∂zL,i
∂wm
tj
¯vu
∂zL,i
∂sm,i
(cid:32) nL(cid:88)
zm−1,i
¯vu
= zm−1,i
∂zL,i
∂sm,i
u=1
nL(cid:88)
u=1
∂zL,i
∂sm,i
¯vu, ∀j ∈ Tm
27
(cid:33)
¯vu
(55)
(56)
are independent of t, we can calculate and store them for the computation in (55).
Therefore, the total computational cost is proportional to
|Tm−1| × |Tm| + nL × |Tm|,
(57)
which is the same as that for (J i
pvp).
In the above discussion, we assume that diagonal blocks of the Gauss-Newton ma-
trix are used. If instead the whole Gauss-Newton matrix is considered, then we calculate
(J i
p1)T (Bi(J i
p2vp2)),
for any two partitions p1 and p2. The same techniques introduced in this section can be
applied because (53) and (55) are two independent operations.
4.3 Subsampled Hessian Newton Method
From (16) we see that the computational cost between the Gauss-Newton matrix and a
vector is proportional to the number of data. To reduce the cost, subsampled Hessian
Newton method (Byrd et al., 2011; Martens, 2010; Wang et al., 2015) have been pro-
posed for selecting a subset of data at each iteration to form an approximate Hessian.
Instead of ∇2f (θ) in (15) we use a subset S to have
(cid:88)
i∈S
|S|
∇2
θθξ(zL,i; yi).
Note that zL,i is a function of θ. The idea behind this subsampled Hessian is that when
a large set of points are under the same distribution,
(cid:88)
i∈S
|S|
ξ(zL,i; yi).
28
is a good approximation of the average training losses. For neural networks we consider
the Gauss-Newton matrix, so (16) becomes the following subsampled Gauss-Newton
matrix.
GS =
|S|
(cid:88)
i∈S
(J i)T BiJ i.
(58)
Now denote the subset at the kth iteration as Sk. The linear system (17) is changed to
(GSk + λkI)dk = −∇f (θk).
After variable partitions, the independent linear systems are
(cid:32)
(cid:33)
(cid:88)
i∈Sk
λkI +
I +
|Sk|
(J i
1)T BiJ i
1 = −gk
dk
1,
(cid:32)
λkI +
(cid:88)
i∈Sk
I +
|Sk|
(J i
P )T BiJ i
(cid:33)
...
P = −gk
dk
P .
(59)
(60)
While using diagonal blocks of the Gauss-Newton matrix avoids the communication
between partitions, the resulting direction may not be as good as that of using the whole
Gauss-Newton matrix. Here we extend an approach by Wang et al. (2015) to pay some
extra cost for improving the direction. Their idea is that after the CG procedure of using
a sub-sampled Hessian, they consider the full Hessian to adjust the direction. Now in
the CG procedure we use a block diagonal approximation of the sub-sampled matrix
GSk, so after that we consider the whole GSk for adjusting the direction. Speciﬁcally, if
dk is obtained from the CG procedure, we solve the following two-variable optimization
problem that involves GSk.
min
β1,β2
(β1dk + β2
¯dk)T GSk(β1dk + β2
¯dk) + ∇f (θk)T (β1dk + β2
¯dk),
(61)
29
where ¯dk is a chosen vector. Then the new direction is
dk ← β1dk + β2
¯dk.
Here we follow Wang et al. (2015) to choose
¯dk = dk−1.
Notice that we choose ¯d0 to be the zero vector. A possible advantage of considering
dk−1 is that it is from the previous iteration of using a different data subset Sk−1 for the
subsampled Gauss-Newton matrix. Thus it provides information from instances not in
the current Sk.
To solve (61), because GSk is positive deﬁnite, it is equivalent to solving the follow-
ing two-variable linear system.
 (dk)T GSkdk
(¯dk)T GSkdk

 β1
β2
 =
 −∇f (θk)T dk
−∇f (θk)T ¯dk
 .
(62)
(¯dk)T GSkdk
(¯dk)T GSk ¯dk
Note that the construction of (62) involves the communication between partitions; see
detailed discussion in Section V of supplementary materials. The effectiveness of using
(61) is investigated in Section VII.
In some situations, the linear system (62) may be ill-conditioned. We set β1 = 1
and β2 = 0 if
where ε is a small number.
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(dk)T GSkdk
(¯dk)T GSkdk
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12) ≤ ε,
(¯dk)T GSkdk
(¯dk)T GSk ¯dk
30
(63)
4.4 Synchronization Between Partitions
While the setting in (51) has made each node conduct its own CG procedure without
communication, we must wait until all nodes complete their tasks before getting into
the next Newton iteration. This synchronization cost can be signiﬁcant. We note that
the running time at each partition may vary because of the following reasons.
1. Because we select a subset of weights between two layers as a partition, the number
of variables in each partition may be different. For example, assume the network
structure is
50-100-2.
The last layer has only two neurons because of the small number of classes. For
the weight matrix W m, a partition between the last two layers can have at most
200 variables. In contrast, a partition between the ﬁrst two layers may have more
variables. Therefore, in the split of variables we should make partitions as balanced
as possible. A example will be given later when we introduce the experiment settings
in Section 8.1.
2. Each node can start its ﬁrst CG iteration after the needed information is available.
From (30)-(34), the calculation of the information needed for matrix-vector products
involves a backward process, so partitions corresponding to neurons in the last layers
start the CG procedure earlier than those of the ﬁrst layers.
To reduce the synchronization cost, a possible solution is to terminate the CG pro-
cedure for all partitions if one of them reaches its CG stopping condition:
(cid:88)
i∈Sk
||(λk +
)vp +
|Sk|
(J i
p)T BiJ i
pvp + gp|| ≤ σ||gp||.
(64)
31
However, under this setting the CG procedure may terminate too early because some
partitions have not conducted enough CG steps yet. To strike for a balance, in our
implementation we terminate the CG procedure for all partitions when the following
conditions are satisﬁed:
1. Every partition has reached a pre-speciﬁed minimum number of CG iterations, CGmin.
2. A certain percentage of partitions have reached their stopping conditions, (64).
In Section 8.1, we conduct experiments with different percentage values to check the
effectiveness of this setting.
4.5 Summary of the Procedure
We summarize in Algorithm 3 the proposed distributed subsampled Hessian Newton
algorithm. Besides materials described earlier in this section, here we explain other
steps in the algorithm.
First, in most optimization algorithms, after a direction dk is obtained, a suitable
step size αk must be decided to ensure the sufﬁcient decrease of f (θk + αkdk). Here
4, . . .} such
we consider a backtracking line search by selecting the largest αk ∈ {1, 1
2, 1
that the following sufﬁcient decrease condition on the function value holds.
f (θk + αkdk) ≤ f (θk) + ηαk∇f (θk)T dk,
(65)
where η ∈ (0, 1) is a pre-deﬁned constant.
Secondly, we follow Martens (2010); Martens and Sutskever (2012); Wang et al.
(2015) to apply the Levenberg-Marquardt method by introducing a term λkI in the
32
linear system (17). Deﬁne
ρk =
f (θk + αkdk) − f (θk)
αk∇f (θk)T dk + 1
2(αk)2(dk)T GSkdk
as the ratio between the actual function reduction and the predicted reduction. Based
on ρk, the following rule derives the next λk+1.

λk+1 =
λk × drop
ρk > 0.75,
λk
0.25 ≤ ρk ≤ 0.75,
(66)
λk × boost
otherwise,
where (drop,boost) are given constants. Therefore, if the predicted reduction is close
to the true function reduction, we reduce λk such that a direction closer to the Newton
direction is considered. In contrast, if ρk is small, we enlarge λk so that a conservative
direction close to the negative gradient is considered.
Note that line search already serves as a way to adjust the direction according to
the function-value reduction, so in optimization literature line search and Levenberg-
Marquardt method are seldom applied concurrently. Interestingly, in recent studies of
Newton methods for neural networks, both techniques are considered. Our preliminary
investigation in Section VI of supplementary materials shows that using Levenberg-
Marquardt method together with line search is very helpful, but more detailed studies
can be a future research issue.
In Algorithm 3 we show a master-master implementation, so the same program is
used at each partition. Some careful designs are needed to ensure that all partitions
get consistent information. For example, we can use the same random seed to ensure
that at each iteration all partitions select the same set Sk in constructing the subsampled
33
Gauss-Newton matrix.
5 Analysis of the Proposed Algorithm
In this section, we analyze Algorithm 3 on the memory requirement, the computational
cost, and the communication cost. We assume that the full training set is used. If the
subsampled Hessian method in Section 4.3 is applied, then in the Jacobian calculation
and the Gauss-Newton matrix vector product the “l” term in our analysis should be
replaced by the subset size |S|.
5.1 Memory Requirement at Each Partition
Assume the partition corresponds to the neuron sub-groups Tm−1 at layer m− 1 and Tm
at layer m. We then separately consider the following situations.
1. Local weight matrix: Each partition must store the local weight matrix.
tj , ∀t ∈ Tm−1, and ∀j ∈ Tm.
wm
If Tm−1 is the ﬁrst neuron sub-group of layer m − 1, it also needs to store
j , ∀j ∈ Tm.
bm
Therefore, the memory usage at each partition for the local weight matrix is propor-
tional to
|Tm−1| × |Tm| + |Tm|.
34
2. Function evaluation: From Section 3.2, we must store part of zm−1,i and zm,i vec-
tors.4 The memory usage at each partition is
l × (|Tm−1| + |Tm|).
(67)
3. Gradient evaluation: First, we must store
∂f
∂wm
tj
and ∂f
∂bm
, t ∈ Tm−1, j ∈ Tm
after the gradient evaluation. Second, for the backward process, from (45), we must
store
∂ξi
∂zm−1,i
, ∀t ∈ Tm−1, ∀i and
, ∀j ∈ Tm, ∀i.
∂ξi
∂zm,i
Therefore, the memory usage in each partition is proportional to
(|Tm−1| × |Tm| + |Tm|) + l × (|Tm−1| + |Tm|).
(68)
4. Jacobian evaluation: From the discussion in Section 3.3.1, the memory consumption
is proportional to
l × nL × (|Tm−1| + |Tm|).
(69)
In summary, the memory bottleneck is on terms that are related to the number of in-
stances. To reduce the memory use, we have considered a technique in Section 4.3 to
replace the term l in (69) with a smaller subset size |Sk|. We will further discuss a
technique to reduce the memory consumption in Section 6.1.
4Note that the same vector is used to store the s vector before it is transformed to z by the activation
function.
35
5.2 Computational Cost
We analyze the computational cost at each partition. For the sake of simplicity, we
make the following assumptions.
• At the mth layer neurons are evenly split to several sub-groups, each of which
has |Tm| elements.
• Calculating the activation function σ(s) needs 1 operation.
The following analysis is for a partition between layers m − 1 and m.
1. Function evaluation: From Algorithm 1, after sm−1,i
, i = 1, . . . , l, t ∈ Tm−1 are
available, we must calculate (19) and (20). The dominant one is (20), so the compu-
tational cost of function evaluation is
O(l × |Tm| × |Tm−1|).
(70)
2. Gradient evaluation: Assume that the current partition has received ∂ξi/∂zm,i
, i =
1, . . . , l, j ∈ Tm. From (44), we calculate
l(cid:88)
l(cid:88)
i=1
i=1
∂f
∂wm
tj
wm
tj +
wm
tj +
which costs
∂ξi
∂wm
tj
∂ξi
∂zm,i
σ(cid:48)(sm,i
)zm−1,i
, ∀t ∈ Tm−1, ∀j ∈ Tm,
O(l × |Tm| × |Tm−1|).
Then for the reduce operation in (45), calculating the local sum
(cid:88)
j∈Tm
σ(cid:48)(sm,i
tj , i = 1, . . . , l, t ∈ Tm−1.
)wm
∂ξi
∂zm,i
36
has a similar cost. Thus the computational cost of gradient evaluation is
O(l × |Tm| × |Tm−1|).
(71)
3. Jacobian evaluation: From (46) and (47) in Algorithm 2, the computational cost is
O(nL × l × |Tm| × |Tm−1|).
(72)
4. Gauss-Newton matrix-vector products: Following (57) in Section 4.2, , the compu-
tational cost for Gauss-Newton matrix vector products is
# CG iterations × (l × (|Tm−1| × |Tm| + nL × |Tm|)) .
(73)
From (70)-(73), we can derive the following conclusions.
1. The computational cost is proportional to the number of training data, the number of
classes, and the number of variables in a partition.
2. In general, (72) and (73) dominate the computational cost. Especially, when the
number of CG iterations is large, (73) becomes the bottleneck.
3. If the subsampling techniques in Section 4.3 is used, then l in (72)-(73) is replaced
with the size of the subset. Therefore, the computational cost at each partition in a
Newton iteration can be effectively reduced. However, the number of iterations may
be increased.
4. The computational cost can be reduced by splitting neurons at each layer to as many
sub-groups as possible. However, because each partition corresponds to a computing
node, more partitions imply a higher synchronization cost. Further, the total number
of neurons at each layer is different, so the size of each partition may signiﬁcant
vary, a situation that further worsens the synchronization issue.
37
5.3 Communication Cost
We have shown in Section 3.1 that by using diagonal blocks of the Gauss-Newton
matrix, each partition conducts a CG procedure without communicating with others.
However, communication cost still occurs for function, gradient, and Jacobian evalua-
tion. We discuss details for the Jacobian evaluation because the situation for others is
similar.
To simplify the discussion we make the following assumptions.
1. At the mth layer neurons are evenly split to several sub-groups, each of which has
|Tm| elements. Thus the number of neuron sub-groups at layer m is nm/|Tm|.
2. Each partition sends or receives one message at a time.
3. Following Barnett et al. (1994), the time to send or receive a vector v is
α + β × |v|,
where |v| is the length of v, α is the start-up cost of a transfer and β is the transfer
rate of the network.
4. The time to add a vector v and another vector of the same size is
γ × |v|.
5. Operations (including communications) of independent groups of nodes can be con-
ducted in parallel. For example, the two trees in Figure IV.3 of supplementary ma-
terials involve two independent sets of partitions. We assume that the two reduce
operations can be conducted in parallel.
38
From (36), for partitions between layers m − 1 and m that correspond to the same
neuron sub-group Tm−1 at layer m − 1, the reduce operation on ∂zL,i
1, . . . , nL, t ∈ Tm−1, i = 1, . . . , l sums up
u /∂zm−1,i
, u =
nm|Tm| vectors of l × nL × |Tm−1| size.
For example, the layer 2 in Figure 2 is split to three groups A2, B2 and C2, so for the
sub-group A1 in layer 1, three vectors from (A1, A2), (A1, B2) and (A1, C2) are reduced.
Following the analysis in Pjeˇsivac-Grbovi´c et al. (2007), the communication cost for the
reduce operation is
O((cid:100)(log2(
nm|Tm|)(cid:101) × (α + (β + γ) × (l × nL × |Tm−1|)) .
(74)
Note that between layers m − 1 and m
nm−1
|Tm−1| reduce operations
are conducted and each takes the communication cost shown in (74). However, by our
assumption they can be fully parallelized.
The reduced vector of size l × nL × |Tm−1| is then broadcasted to nm−2/|Tm−2|
partitions. Similar to (74), the communication cost is
O((cid:100)(log2(
nm−2
|Tm−2|)(cid:101) × (α + β × (l × nL × |Tm−1|))).
(75)
The γ factor in (74) does not appear here because we do not need to sum up vectors.
Therefore, the total communication cost of the Jacobian evaluation is the sum of
(74) and (75). We can make the following conclusions.
1. The communication cost is proportional to the number of training instances as
well as the number of classes.
39
2. From (74) and (75), a smaller |Tm−1| reduces the communication cost. However,
we can not split neurons at each layer to too many groups because of the following
reasons. First, we assumed earlier that for independent sets of partitions, their
operations including communication within each set can be fully parallelized.
In practice, the more independent sets the higher synchronization cost. Second,
when there are too many partitions the block diagonal matrix in (49) may not be
a good approximation of the Gauss-Newton matrix.
6 Other Implementation Techniques
In this section, we discuss additional techniques implemented in the proposed algo-
rithm.
6.1 Pipeline Techniques for Function and Gradient Evaluation
The discussion in Section 5 indicates that in our proposed method the memory require-
ment, the computational cost and the communication cost all linearly increase with the
number of data. For the product between the Gauss-Newton matrix and a vector, we
have considered using subsampled Gauss-Newton matrices in Section 4.3 to effectively
reduce the cost. To avoid that function and gradient evaluations become the bottleneck,
here we discuss a pipeline technique.
The idea follows from the fact that in (4)
ξi,∀i
40
are independent from each other. The situation is the same for
(J i)T∇zL,iξ(zL,i; yi),∀i
in (6). Therefore, in the forward (or the backward) process, once results related to an
instance xi are ready, they can be passed immediately to partitions in the next (or pre-
vious) layers. Here we consider a mini-batch implementation. Take the function evalu-
ation as an example. Assume {1, . . . , l} is split to R equal-sized subsets S1, . . . , SR. At
a variable partition between layers m − 1 and m, we showed earlier that local values in
(20) are obtained for all instances i = 1, . . . , l. Now instead we calculate
(cid:88)
t∈Tm−1
tj zm−1,i
wm
+ bm
j , j ∈ Tm, i ∈ Sr.
The values are used to calculate
, ∀i ∈ Sr.
sm,i
By this setting we achieve better parallelism. Further, because we split {1, . . . , l} to
subsets with the same size, the memory space allocated for a subset can be reused by
another. Therefore, the memory usage is reduced by R folds.
6.2 Sparse Initialization
A well-known problem in training neural networks is the easy overﬁtting because of an
enormous number of weights. Following the approach in Section 5 of Martens (2010),
we implement the sparse initialization for the weights to train deep neural networks. For
each neuron in the mth layer, among the nm−1 weights connected to it, we randomly
assign several weights to have values from the N (0, 1) distribution. Other weights are
kept zero.
41
We will examine the effectiveness of this initialization in Sections 8.2 and 8.3.
7 Existing Optimization Methods for Training Neural
Networks
Besides Newton methods considered in this work, many other optimization methods
have been applied to train neural networks. We brieﬂy discuss the most commonly used
one in this section.
7.1 Stochastic Gradient Methods
For deep neural networks, it is time-consuming to calculate the gradient vector because
from (6), we must go through the whole training data set. Instead of using all data
instances, stochastic gradient (SG) methods randomly choose an example (yik, xik) to
derive the following sub-gradient vector to update the weight matrix.
∇f ik(θk) =
θk
+ (J ik)T∇zL,ik ξ(zL,ik; yik).
Algorithm 4 gives the standard setting of SG methods.
Assume that one epoch means the SG procedure goes through the whole training
data set once. Based on the frequent updates of the weight matrix, SG methods can
get a reasonable solution in a few epochs. Another advantage of SG methods is that
Algorithm 4 is easy to implement. However, if the variance of the gradient vector
for each instance is large, SG methods may have slow convergence. To address this
issue, mini-batch SG method have been proposed to accelerate the convergence speed
42
(e.g., Bottou, 1991; Dean et al., 2012; Ngiam et al., 2011; Baldi et al., 2014). Assume
Sk ⊂ {1, . . . , l} is a subset of the training data. The sub-gradient vector can be as
follows:
∇f Sk(θk) =
θk
|Sk|
(cid:88)
i∈Sk
(J i)T∇zL,iξ(zL,i; yi).
However, when SG methods meet ravines which cause the particular dimension appar-
ent to other dimensions, they are easier to drop to local optima. Polyak (1964) proposes
using the previous direction with momentum as part of the current direction. This set-
ting may decrease the impact of a particular dimension. Algorithm 5 gives details of a
mini-batch SG method with momentum implemented in Theano/Pylearn2 (Goodfellow
et al., 2013).
Many other variants of SG methods have been proposed, but it has been shown (e.g.,
Sutskever et al., 2013) that the mini-batch SG with momentum is a strong baseline. Thus
in this work we do not include other types of SG algorithms for comparison.
Unfortunately, both SG and mini-batch SG methods have a well known issue in
choosing a suitable learning rate and a momentum coefﬁcient for different problems.
We will conduct some experiments in Section 8.
8 Experiments
We consider the following data sets for experiments. All except Sensorless come with
training and test sets. We split Sensorless as described below.
• HIGGS: This binary classiﬁcation data set is from high energy physics applica-
tions. It is selected for our experiments because feedforward networks have been
43
successfully applied (Baldi et al., 2014). Note that a scalar output y is enough to
represent two classes in a binary classiﬁcation problem. Based on this idea, we
set nL = 1, and have each yi ∈ {−1, 1}. The predicted outcome is the ﬁrst class
if y ≥ 0 and is the second class if y < 0. This data set is mainly used in Section
8.3 for a comparison with results in Baldi et al. (2014).
• Letter: This set is from the Statlog collection (Michie et al., 1994) and we scale
values of each feature to be in [−1, 1].
• MNIST: This data set for hand-written digit recognition (LeCun et al., 1998a) is
widely used to benchmark classiﬁcation algorithms. We consider a scaled ver-
sion, where every feature value is divided by 255.
• Pendigits: This data set is originally from Alimoglu and Alpaydin (1996).
• Poker: This data set is from UCI machine learning repository (Lichman, 2013).
It has been studied by, for example, Li (2010).
• Satimage: This set is from the Statlog collection (Michie et al., 1994) and we
scale values of each feature to be in [−1, 1].
• SensIT Vehicle: This data set, from Duarte and Hu (2004), includes signals from
acoustic and seismic sensors in order to classify the different vehicles. We use
the original version without scaling.
• Sensorless: This data set is from Paschke et al. (2013). We scale values of
each feature to be in [0, 1], and then conduct stratiﬁed random sampling to select
10, 000 instances to be the test set and the rest of the data to be the training set.
44
• SVHN: This data, originally from Google Street View images, consists of colored
images of house numbers (Netzer et al., 2011). We scale the data set to [0, 1] by
considering the largest and the smallest feature values of the entire data set.
M ≡ max
max
(xi)p and m ≡ min
min
(xi)p.
Then the pth element of xi is changed to
(xi)p ← (xi)p − m
M − m
• USPS: This data set, from Hull (1994), is used on recognizing handwritten ZIP
codes and we scale values of each feature to be in [−1, 1].
All data sets, with statistics in Table 1, are publicly available.5 Detailed settings for
each data such as the network structure are given in Table 2. How to decide a suitable
network structure is beyond the scope of this work, but if possible, we follow the setting
in earlier works. For example, we consider the structure in Wan et al. (2013) for MNIST
and Neyshabur et al. (2015) for SVHN. From Table 2, the model used for SVHN is the
largest. If the number of neurons in each layer is further increased, then the model must
be stored in different machines.
We give parameters used in our algorithm. For the sparse initialization discussed
nm−1(cid:101) are
in Section 6.2, among nm−1 weights connected to a neuron in layer m, (cid:100)√
selected to have non-zero values. For the CG stopping condition (52), we set σ = 0.001
and CGmax = 250. Further, the minimal number of CG steps run at each partition,
CGmin, is set to be 3. For the implementation of the Levenberg-Marquardt method, we
5All data sets used can be found at https://www.csie.ntu.edu.tw/˜cjlin/
libsvmtools/datasets/.
45
Table 1: Summary of the data sets: n0 is the number of features, l is the number of
training instances, lt is the number of testing instances, and K is the number of classes.
n0
16
lt K
15,000
5,000 26
784
60,000
10,000 10
16
10
36
7,494
3,498 10
25,010 1,000,000 10
4,435
2,000
Data set
Letter
MNIST
Pendigits
Poker
Satimage
SensIT Vehicle
100
78,823
19,705
Sensorless
48
48,509
10,000 11
SVHN
USPS
HIGGS
3,072
73,257
26,032 10
256
7,291
2,007 10
28 10,500,000
500,000
set the initial λ1 = 1. The (drop, boost) constants in (66) are (2/3, 3/2). For solving
(61) to get the update direction after the CG procedure, we set ε = 10−5 in (63).
8.1 Analysis of Distributed Newton Methods
We have proposed several techniques to improve upon the basic implementation of the
Newton method in a distributed environment. Here we investigate their effectiveness by
considering the following methods. Note that because of the high memory consumption
of some larger sets, we always implement the subsampled Hessian Newton method
46
Table 2: Details of the distributed network for each data. Sampling rate is the percentage
of training data used to calculate the subsampled Gauss-Newton matrix.
Data set
Letter
MNIST
Pendigits
Poker
SensIT Vehicle
Sensorless
Satimage
SVHN
USPS
Sampling rate
Network structure
Split structure # partitions
20%
20%
20%
20%
20%
20%
20%
10%
20%
16-300-300-300-300-26
1-2-1-1-1-1
784-800-800-10
16-300-300-10
1-1-3-1
1-2-2-1
10-200-200-200-10
1-1-1-1-1
100-300-300-3
1-2-2-1
48-300-300-300-11
1-2-1-2-1
36-1000-500-6
1-2-2-1
3072-4000-4000-10
3-2-2-1
256-300-300-10
1-2-2-1
12
discussed in Section 4.3.
1. subsampled-GN: we use the whole subsampled Gauss-Newton matrix deﬁned in (58)
to conduct the matrix-vector product in the CG procedure and then solve (61) to get
the update direction after the CG procedure (Wang et al., 2015).
2. diag: it is the same as subsampled-GN except that only diagonal blocks of the sub-
sampled Gauss-Newton matrix are used; see (60).
3. diag + sync 50%: it is the same as diag except that we consider the technique in
Section 4.4 to reduce the synchronization time. We terminate the CG procedure
when 50% of partitions have reached their local stopping conditions (64).
47
4. diag + sync 25%: it is the same as diag + sync 50% except that we terminate the
CG procedure when 25% of partitions have reached their local stopping conditions
(64).
For each of the above methods, we consider the following implementation details.
1. We set C = l as the regularization parameter.
2. We run experiments on G1 type instances on Microsoft Azure and let each instance
use only one core. If instances are not virtual machines on the same computer, our
setting ensures that each variable partition corresponds to one machine.
3. To make the computational cost in each partition as balanced as possible, in our ex-
periments we choose our partitions such that the maximum ratio between the num-
bers of variables (|Tm|×|Tm−1|) among any two partitions is as low as possible. For
example, in Pendigits, the largest partition has 150 × 150 = 22, 500 weight vari-
ables, and the smallest partition has 150 × 10 = 1, 500 weight variables, with their
ratio being 22500/1500 = 15. For most data sets, the ratio is between 10 and 100
but not lower because the numbers of classes is relatively small, making the number
of variables in the partitions involving the output layer smaller than those in other
partitions.
In Figure 4, we show the comparison results and have the following observations.
1. For test accuracy versus number of iterations, subsampled-GN in general has the
fastest convergence rate. The reason should be that the direction in subsampled-GN
48
by solving the linear system (59) is closer to the full Newton direction than other
methods, which consider further approximations of the Gauss-Newton matrix or the
early termination of the CG procedure. However, the cost per iteration is high, so for
training time we see that subsampled-GN may become worse than other approaches.
2. The early termination of the CG procedure can effectively reduce the cost per iter-
ation. However, if we stop the CG procedure too early, the total training time may
even increase. For example,
diag + sync 25%
is generally the fastest in the beginning because of the least cost per iteration. It is
still the fastest in the end for MNIST, Letter, USPS, Satimage, and Pendigits.
However, it has the slowest ﬁnal convergence for SensIT Vechicle, Poker, and
Sensorless. Take the data set Poker as an example. As listed in Table 2, the
variables are split into four partitions, and the CG procedure stops if one partition
(i.e., 25% of the partitions) reaches its local stopping condition. This partition may
have the lightest computational load or is the earliest one to start solving the local
linear system.6 Thus the other partitions may not have run enough CG iterations.
The approach
diag + sync 50%
does not terminate the CG procedure that early. Overall we ﬁnd that it is efﬁcient
6Note that because of the backward process in Section 3.3, the partitions corresponding to the last
two layers begin their CG procedures earlier than the others.
49
and stable. Therefore, in subsequent comparisons with stochastic gradient methods,
we use it as the setting of our Newton method.
Because of the space consideration, we have evaluated only some techniques pro-
posed in Section 4. For the following two techniques we leave details in Sections VI
and VII of the supplementary materials.
1. In Section 4.3, we propose combining dk and dk−1 as the update direction. We show
that this technique is very effective.
2. We mentioned in Section 4.5 that line search and the Levenberg-Marquardt (LM)
method may not be both needed. Our preliminary results show that the training
speed is improved when both techniques are applied.
8.2 Comparison with Stochastic Gradient Methods and Support
Vector Machines (SVM)
In this section, we compare our methods with SG methods and SVMs, which are pop-
ularly used for multi-class classiﬁcation. Settings of these methods are described as
follows.
1. Newton: for our method we use the setting diag + sync 50% considered in Section
8.1 and let C = l.
2. SVM (Boser et al., 1992): We consider the RBF kernel.
K(xi, xj) = e−γ||xi−xj||2,
50
where xi and xj are two data instances, and γ is the kernel parameter chosen by
users. Note that SVM solves an optimization problem similar to (4), so the regu-
larization parameter, C, must be decided as well. We conduct ﬁve-fold cross vali-
dation on the training set to select the best C ∈ {2−5l, 2−3l, . . . , 215l} and the best
γ ∈ {2−15, 2−13, . . . , 23}.7 We use the library LIBSVM (Chang and Lin, 2011) for
training and prediction.
3. SG: We use the code from Baldi et al. (2014), which implements Algorithm 5. The
objective function is the same as (4).8 The network structure for each data set is
identical to the corresponding one used in Newton, and we also set the regularization
parameter C = l. The major modiﬁcation we make is that we replace their activation
functions with ours. In Baldi et al. (2014), the authors use tanh as their activation
functions in layers 1, . . . , L − 1 and the sigmoid function in layer L, while in our
experiments of Newton methods in Section 8.1, we use the sigmoid function in layers
1, . . . , L − 1 and the linear function in layer L. The initial learning rate is selected
from {0.05, 0.025, 0.01, 0.005, 0.002, 0.001} by the ﬁve-fold cross validation. After
the initial learning rate has been selected, we conduct the training process to generate
a model for the prediction on the test set.
As regards the stopping condition for the training process, we terminate the Newton
7Here we consider an SVM formulation represented as (2). In the form considered in LIBSVM, the
two terms C and 1/l are combined together, so C/l is the actual parameter to be selected. For SVHN
because of the lengthy time for parameter selection, we selected only 10, 000 instances by stratiﬁed
sampling to conduct the ﬁve-fold cross validation.
8Following Baldi et al. (2014), we regularized only the weights but not the biases. Through several
experiments, we found that the performance is similar with/without the regularization of the biases.
51
method at the 100th iteration. For SG, it terminates after a minimal number of epochs
have been conducted and the objective function value on the validation set does not
improve much within the last N epochs (see Algorithm 5). To implement the stopping
condition, for SG we split the input training set into 90% for training and 10% for
validation.9 For SVM, we use the default stopping condition of LIBSVM.10
Here we also investigate the effect of the initialization by considering the following
two settings.
1. The sparse initialization discussed in Section 6.2.
2. The dense initialization discussed in Baldi et al. (2014). The initial weights are
drawn from the normal distribution N (0, 0.12) for the ﬁrst layer, N (0, 0.0012) for
the output layer, and N (0, 0.052) for other hidden layers. The biases are initialized
as zeros.
To make a fair comparison, for each setting, Newton and SG are trained with the same
initial weights and biases.
We present a comparison on test accuracy in Table 3, and make the following ob-
servations.
1. For neural networks, the sparse initialization usually results in better accuracy than
the dense initialization does. The difference can be huge in some cases, such as
9Note that in the CV procedure we also need a stopping condition in training each sub-problem. We
do an 80-20 split of every four folds of data so that the 20% of data are used to implement the stopping
condition.
10LIBSVM terminates when the violation of the optimality condition calculated based on the gradient
is smaller than a tolerance.
52
training using SG on the data set Letter. The low accuracy of the densely initialized
SG on Letter may be because of the poor differentiation between neurons in dense
initialization (Martens, 2010). Other possible causes include the vanishing gradient
problem (Bengio et al., 1994), or that the activations are trapped in the saturation
regime of the sigmoid function (Glorot and Bengio, 2010). Note that the impact of
the initialization scheme on the Newton method is much weaker.11
2. Between SG and Newton, if sparse initialization is used, we can see that Newton
generally gives higher accuracy.
3. If sparse initialization is used, our Newton method for training neural networks gives
similar or higher accuracy than SVM. In particular, the results are much better for
Poker and SVHN.
We compare our results on MNIST with those reported in earlier works. Wan et al.
(2013) use a fully connected neural network with two 800-neuron hidden layers to de-
rive an error rate 1.36%, under the setting of dense initialization,12 sigmoid activations,
and the dropout technique. By the same network structure and the same activation func-
tion, our error rate is 1.34% at the 100th iteration.
For SVHN, we compare our results with Neyshabur et al. (2015), in which the
same network structure as ours is adopted, except that they use ReLU activations in the
hidden layers. They choose the cross-entropy as their objective function, and utilize the
11We observe similar phenomena in the experiments with HIGGS later in Section 8.3. See Table 5.
12In Wan et al. (2013), the initial weights are drawn from N (0, 0.01), slightly different from the dense
initialization we use.
53
dropout regularization. Under dense initialization,13 they train their network with the
Path-SGD method, which uses a proximal gradient method to solve the optimization
problem. They report an accuracy slightly below 87% (see their Figure 3), while the
accuracy obtained by our Newton method with sparse initialization is 83.12%.
For Poker, we note that Li (2010) uses abc-logitboost to obtain a slightly higher
accuracy, but his setting is different from ours. He expands the training set by including
half of the test set, with the remaining half of the test set used for evaluation.
An issue found out in our experiments is that SG is sensitive to the initial learning
rate. In Table 4, we present the test accuracy of SG under different initial rates for the
Poker problem. Clearly an inappropriate initial learning rate can lead to much worse
accuracy.
8.3 Detailed Investigation on the HIGGS Data
We compare AUC values obtained by our Newton and SG implementations with those
reported in Baldi et al. (2014) on HIGGS. In our method, the sampling rate for cal-
culating the subsampled Gauss-Newton matrix is set to be 1%. Following the setting
in Section 8.2, we consider two initializations (dense and sparse). Then for each type
of initialization, both SG and Newton start with the same initial weights and biases.
Note that our SG results are different from those in Baldi et al. (2014) because we use
different activation functions and initial values for weights and biases.14 Because of
13In Neyshabur et al. (2015), the initial weights wm
tj are drawn from N (0, 1/nm−1), slightly different
from the dense initialization we use.
14Their initialization setting is the same as our dense initialization, but the values used by them are
not available.
54
Table 3: Test accuracy of SVM, Newton and SG. For SVM, we also show parameters
(C, γ) used. For SG, we show (the initial learning rate, number of epochs to reach the
stopping criterion). The bold-faced entries indicate the best accuracy obtained using the
neural networks.
SVM
Neural Networks
Dense Initialization
Sparse Initialization
Newton
SG
Newton
SG
Letter
MNIST
97.90% (27l, 2)
90.26% 8.02% (0.025, 245) 96.68% 96.28% (0.002, 906)
98.57% (23l, 2−5)
98.52% 98.26% (0.002, 801) 98.66% 98.33% (0.002, 909)
Pendigits
98.06% (27l, 2−15) 97.51% 97.71% (0.001, 513) 97.83% 97.71% (0.002, 1179)
Poker
58.78% (2−1l, 2−3) 99.25% 99.24% (0.005, 316) 99.25% 99.29% (0.002, 895)
Satimage
91.85% (2l, 2)
89.35% 82.00% (0.01, 246) 89.85% 89.35% (0.001, 1402)
SensIT Vehicle 83.90% (2l, 2−1)
85.16% 83.34% (0.01, 311)
84.60% 84.00% (0.01, 296)
Sensorless
99.83% (25l, 23)
97.19% 97.64% (0.01, 412) 99.05% 98.24% (0.005, 382)
SVHN
USPS
74.54% (25l, 2−7)
95.32% (25l, 2−5)
80.96% 82.99% (0.001, 986) 83.12% 82.67% (0.001, 720)
95.17% 94.97% (0.025, 395) 95.27% 95.07% (0.001, 1617)
resource constraints, we did not conduct a validation procedure to select SG’s initial
learning rate. Instead, we used the learning rate 0.05 by following Baldi et al. (2014).
The results are shown in Table 5 and we can see that the Newton method often gives the
best AUC values.
In Section 8.2 we have mentioned that SG’s performance may be sensitive to the
initial learning rate. The poor results of SG in Table 5 might be because we did not
conduct a selection procedure. Thus we decide to investigate the effect of the initial
learning rate on the AUC value with the network structure 28-300-300-1 used in the
55
Table 4: Test accuracy on Poker using SG with different initial learning rates η. Dense
initialization is used. Note that although η = 0.005 does not yield the highest test
accuracy, it was selected for experiments in Table 3 because of giving the highest CV
accuracy.
Initial learning rate η
0.05
0.025
0.01
0.005
0.002
0.001
Test accuracy
68.83% 98.81% 99.24% 99.24% 99.24% 99.25%
earlier experiment in Table 5. To compare the running time, both SG and Newton run
on the same G3 type machine with 8 cores in Microsoft Azure. The results of the
AUC values versus the number of iterations and the training time are shown in Figure
5. We clearly see again that the performance of SG depends signiﬁcantly on the initial
learning rate. Our experiments indicate that while SG can yield good performances
under suitable parameters, the parameter selection procedure is essential. In contrast,
Newton methods are more robust because we do not need to ﬁne tune their parameters.
9 Discussion and Conclusions
For the future works, we list the following directions.
1. It is important to extend the proposed method for other types of neural networks. For
example, convolutional neural networks (CNNs) are popular for computer vision ap-
plications (e.g., Krizhevsky et al., 2012; Simonyan and Zisserman, 2014). Because
56
Table 5: A comparison between the AUC obtained by SG and that by the distributed
Newton on the HIGGS data set. We list the results in Baldi et al. (2014) as a reference,
where “NA” means that the result is not reported. See explanation in Section 8.3 about
the different results between our SG and Baldi et al.’s.
Network
Split
Dense Initialization Sparse Initialization
Newton
SG
Newton
SG
Baldi et al. (2014)
28-300-1
28-600-1
28-1000-1
28-2000-1
2-2-1
2-3-1
2-4-1
2-8-1
0.843
0.469
0.843
0.684
0.849
0.501
0.849
0.759
0.851
0.500
0.853
0.734
0.853
0.500
0.855
0.504
28-300-300-1
2-2-1-1
0.851
0.530
0.860
0.825
28-300-300-300-1
2-2-2-1-1
0.867
0.482
0.879
0.849
28-300-300-300-300-1 2-2-2-2-1-1 0.867
0.504
0.875
0.848
0.816
NA
0.841
0.842
NA
0.850
0.872
CNNs generally have fewer weights per layer, our method has the potential to train
deep networks for large-scale image classiﬁcation.
2. Instead of the Gauss-Newton matrix, we may consider other ways to use or approx-
imate the Hessian such as the recent works by He et al. (2016).
3. For results in Tables 3 and 5, we consider the model after running 100 Newton
iterations. An advantage of Newton over stochastic gradient is that we can apply a
gradient-based stopping condition. We plan to investigate its practical use.
4. It is known that using suitable preconditioners can effectively reduce the number of
57
CG steps in solving a linear system. Studies of applying preconditioned CG methods
in training neural networks include, for example, Chapelle and Erhan (2011). We
plan to investigate how to apply preconditioning in our distributed framework.
In summary, in this paper we proposed novel techniques to implement distributed
Newton methods for training large-scale neural networks, and achieved both data and
model parallelisms.
Acknowledgements
This work was supported in part by MOST of Taiwan via the grant 105-2218-E-002-033
and Microsoft via Azure for Research programs.
References
Alimoglu, F. and Alpaydin, E. (1996). Methods of combining multiple classiﬁers based
on different representations for pen-based handwritten digit recognition.
In Pro-
ceedings of the Fifth Turkish Artiﬁcial Intelligence and Artiﬁcial Neural Networks
Symposium.
Baldi, P., Sadowski, P., and Whiteson, D. (2014). Searching for exotic particles in
high-energy physics with deep learning. Nature Communications, 5.
Barnett, M., Gupta, S., Payne, D. G., Shuler, L., van De Geijn, R., and Watts, J. (1994).
Interprocessor collective communication library (InterCom). In Proceedings of the
Scalable High-Performance Computing Conference, pages 357–364.
58
Bengio, Y., Simard, P., and Frasconi, P. (1994). Learning long-term dependencies with
gradient descent is difﬁcult. IEEE Transactions on Neural Networks, 5(2):157–166.
Bian, Y., Li, X., Cao, M., and Liu, Y. (2013). Bundle CDN: a highly parallelized ap-
proach for large-scale l1-regularized logistic regression. In Proceedings of European
Conference on Machine Learning and Principles and Practice of Knowledge Discov-
ery in Databases (ECML/ PKDD).
Boser, B. E., Guyon, I., and Vapnik, V. (1992). A training algorithm for optimal margin
classiﬁers. In Proceedings of the Fifth Annual Workshop on Computational Learning
Theory, pages 144–152. ACM Press.
Bottou, L. (1991). Stochastic gradient learning in neural networks. Proceedings of
Neuro-Nımes, 91(8).
Bottou, L. (2010). Large-scale machine learning with stochastic gradient descent. In
Proceedings of COMPSTAT 2010, pages 177–186.
Byrd, R. H., Chin, G. M., Neveitt, W., and Nocedal, J. (2011). On the use of stochastic
Hessian information in optimization methods for machine learning. SIAM Journal
on Optimization, 21(3):977–995.
Chang, C.-C. and Lin, C.-J. (2011). LIBSVM: a library for support vector machines.
ACM Transactions on Intelligent Systems and Technology, 2(3):27:1–27:27. Software
available at http://www.csie.ntu.edu.tw/˜cjlin/libsvm.
Chapelle, O. and Erhan, D. (2011). Improved preconditioner for Hessian free optimiza-
tion. In NIPS Workshop on Deep Learning and Unsupervised Feature Learning.
59
Ciresan, D. C., Meier, U., Gambardella, L. M., and Schmidhuber, J. (2010). Deep, big,
simple neural nets for handwritten digit recognition. Neural Computation, 22:3207–
3220.
Dean, J., Corrado, G., Monga, R., Chen, K., Devin, M., Le, Q. V., Mao, M. Z., Ranzato,
M., Senior, A. W., Tucker, P. A., et al. (2012). Large scale distributed deep networks.
In Advances in Neural Information Processing Systems (NIPS) 25.
Duarte, M. and Hu, Y. H. (2004). Vehicle classiﬁcation in distributed sensor networks.
Journal of Parallel and Distributed Computing, 64(7):826–838.
Glorot, X. and Bengio, Y. (2010). Understanding the difﬁculty of training deep feed-
forward neural networks.
In Proceedings of the 13th International Conference on
Artiﬁcial Intelligence and Statistics (AISTATS), pages 249–256.
Goodfellow, I. J., Warde-Farley, D., Lamblin, P., Dumoulin, V., Mirza, M., Pascanu,
R., Bergstra, J., Bastien, F., and Bengio, Y. (2013). Pylearn2: a machine learning
research library.
He, K., Zhang, X., Ren, S., and Sun, J. (2015). Delving deep into rectiﬁers: Surpass-
ing human-level performance on ImageNet classiﬁcation. In Proceedings of IEEE
International Conference on Computer Vision (ICCV).
He, X., Mudigere, D., Smelyanskiy, M., and Tak´aˇc, M. (2016). Large scale distributed
Hessian-free optimization for deep neural network. arXiv preprint arXiv:1606.00511.
Hinton, G. E., Deng, L., Yu, D., Dahl, G., rahman Mohamed, A., Jaitly, N., Senior,
A., Vanhoucke, V., Nguyen, P., Sainath, T., and Kingsbury, B. (2012). Deep neural
60
networks for acoustic modeling in speech recognition: The shared views of four
research groups. IEEE Signal Processing Magazine, 29(6):82–97.
Hull, J. J. (1994). A database for handwritten text recognition research. IEEE Transac-
tions on Pattern Analysis and Machine Intelligence, 16(5):550–554.
Kiros, R. (2013). Training neural networks with stochastic Hessian-free optimization.
arXiv preprint arXiv:1301.3641.
Krizhevsky, A., Sutskever, I., and Hinton, G. E. (2012). ImageNet classiﬁcation with
deep convolutional neural networks. In Pereira, F., Burges, C. J. C., Bottou, L., and
Weinberger, K. Q., editors, Advances in Neural Information Processing Systems 25,
pages 1097–1105.
LeCun, Y., Bottou, L., Bengio, Y., and Haffner, P. (1998a). Gradient-based learning ap-
plied to document recognition. Proceedings of the IEEE, 86(11):2278–2324. MNIST
database available at http://yann.lecun.com/exdb/mnist/.
LeCun, Y., Bottou, L., Orr, G. B., and M¨uller, K.-R. (1998b). Efﬁcient back-
prop. In Neural Networks, Tricks of the Trade, Lecture Notes in Computer Science
LNCS 1524. Springer Verlag.
Li, P. (2010). An empirical evaluation of four algorithms for multi-class classi-
ﬁcation: Mart, abc-mart, robust logitboost, and abc-logitboost.
arXiv preprint
arXiv:1001.1020.
Lichman, M. (2013). UCI machine learning repository.
61
Mahajan, D., Keerthi, S. S., and Sundararajan, S. (2017). A distributed block coordinate
descent method for training l1 regularized linear classiﬁers. Journal of Machine
Learning Research, 18(91):1–35.
Martens, J. (2010). Deep learning via Hessian-free optimization. In Proceedings of the
27th International Conference on Machine Learning (ICML).
Martens, J. and Sutskever, I. (2012). Training deep and recurrent networks with
Hessian-free optimization. In Neural Networks: Tricks of the Trade, pages 479–535.
Springer.
Michie, D., Spiegelhalter, D. J., Taylor, C. C., and Campbell, J., editors (1994). Ma-
chine learning, neural and statistical classiﬁcation. Ellis Horwood, Upper Sad-
dle River, NJ, USA. Data available at http://archive.ics.uci.edu/ml/
machine-learning-databases/statlog/.
Moritz, P., Nishihara, R., Stoica, I., and Jordan, M. I. (2015). SparkNet: Training deep
networks in Spark. arXiv preprint arXiv:1511.06051.
Netzer, Y., Wang, T., Coates, A., Bissacco, A., Wu, B., and Ng, A. Y. (2011). Reading
digits in natural images with unsupervised feature learning. In NIPS Workshop on
Deep Learning and Unsupervised Feature Learning.
Neyshabur, B., Salakhutdinov, R. R., and Srebro, N. (2015).
Path-SGD: Path-
normalized optimization in deep neural networks. In Cortes, C., Lawrence, N. D.,
Lee, D. D., Sugiyama, M., and Garnett, R., editors, Advances in Neural Information
Processing Systems 28, pages 2422–2430.
62
Ngiam, J., Coates, A., Lahiri, A., Prochnow, B., Le, Q. V., and Ng, A. Y. (2011). On
optimization methods for deep learning.
In Proceedings of the 28th International
Conference on Machine Learning, pages 265–272.
Paschke, F., Bayer, C., Bator, M., M¨onks, U., Dicks, A., Enge-Rosenblatt, O., and
Lohweg, V. (2013). Sensorlose zustands¨uberwachung an synchronmotoren. In Pro-
ceedings of Computational Intelligence Workshop.
Pearlmutter, B. A. (1994). Fast exact multiplication by the Hessian. Neural Computa-
tion, 6(1):147–160.
Pjeˇsivac-Grbovi´c, J., Angskun, T., Bosilca, G., Fagg, G. E., Gabriel, E., and Dongarra,
J. J. (2007). Performance analysis of MPI collective operations. Cluster Computing,
10:127–143.
Polyak, B. T. (1964). Some methods of speeding up the convergence of iteration meth-
ods. USSR Computational Mathematics and Mathematical Physics, 4(5):1–17.
Schraudolph, N. N. (2002). Fast curvature matrix-vector products for second-order
gradient descent. Neural Computation, 14(7):1723–1738.
Simonyan, K. and Zisserman, A. (2014). Very deep convolutional networks for large-
scale image recognition. arXiv preprint arXiv:1409.1556.
Sutskever, I., Martens, J., Dahl, G., and Hinton, G. (2013). On the importance of ini-
tialization and momentum in deep learning. In Proceedings of the 30th International
Conference on Machine Learning (ICML), pages 1139–1147.
63
Taylor, G., Burmeister, R., Xu, Z., Singh, B., Patel, A., and Goldstein, T. (2016). Train-
ing neural networks without gradients: A scalable ADMM approach. In Proceedings
of The Thirty Third International Conference on Machine Learning, pages 2722–
2731.
Thakur, R., Rabenseifner, R., and Gropp, W. (2005). Optimization of collective com-
munication operations in MPICH. International Journal of High Performance Com-
puting Applications, 19(1):49–66.
Wan, L., Zeiler, M., Zhang, S., LeCun, Y., and Fergus, R. (2013). Regularization
of neural networks using DropConnect.
In Proceedings of the 30th International
Conference on Machine Learning (ICML), pages 1058–1066.
Wang, C.-C., Huang, C.-H., and Lin, C.-J. (2015). Subsampled Hessian Newton meth-
ods for supervised learning. Neural Computation, 27:1766–1795.
Zinkevich, M., Weimer, M., Smola, A., and Li, L. (2010). Parallelized stochastic gra-
dient descent. In Lafferty, J., Williams, C. K. I., Shawe-Taylor, J., Zemel, R., and
Culotta, A., editors, Advances in Neural Information Processing Systems 23, pages
2595–2603.
64
Algorithm 1 Function evaluation in a distributed system
1: Let Tm−1 and Tm be the subsets of neurons at the (m − 1)th and mth layers corre-
sponding to the current partition.
from input, where i = 1, . . . , l, and t ∈ Tm−1.
2: if m = 1 then
Read sm−1,i
3:
4: else
5:
Wait for sm−1,i
Calculate zm−1,i
, i = 1, . . . , l, t ∈ Tm−1.
by (19).
6:
7: end if
8: After calculating (20), run an allreduce operation to have
, i = 1, . . . , l and j ∈ Tm,
sm,i
(27)
available in all partitions between layers m − 1 and m corresponding to Tm.
9: if Tm−1 is the ﬁrst neuron sub-group of layer m − 1 then
10:
if m < L then
11:
12:
13:
14:
We broadcast values in (27) to partitions between layers m and m + 1
corresponding to the neuron subgroup Tm; see the description after (23)
else
Calculate
l(cid:88)
(cid:88)
i=1
j∈TL
ξ(zL,i
; yi
j) + accumulated regularization terms
If TL is the ﬁrst neuron sub-group of layer L, run a reduce operation
to get the ﬁnal f; see (24).
end if
15:
16: end if
65
Algorithm 2 Calculation of ∂zL,i
tributed system.
1: Let Tm−1 and Tm be the subsets of neurons at the (m − 1)th and mth layers corre-
, u = 1, . . . , nL, j = 1, . . . ,|Tm| in a dis-
u /∂sm,i
sponding to the current partition.
2: if m = L then
Calculate
3:
∂zL,i
∂zm,i
2(zL,i
u − yi
u)
if j = u,
if j (cid:54)= u,
, u = 1, . . . , nL, i = 1, . . . , l, and j ∈ Tm.
Wait for ∂zL,i
u /∂zm,i
4: else
5:
6: end if
7: Calculate
, u = 1, . . . , nL, i = 1, . . . , l, and j ∈ Tm.
∂zL,i
∂sm,i
∂zL,i
∂zm,i
σ(cid:48)(sm,i
), u = 1, . . . , nL, i = 1, . . . , l, and j ∈ Tm.
(46)
(47)
(48)
8: if m > 1 then
9:
Calculate the local sum (cid:88)
j∈Tm
tj , t ∈ Tm−1
wm
∂zL,i
∂sm,i
and do the reduce operation to obtain
∂zL,i
∂zm−1,i
, u = 1, . . . , nL, i = 1, . . . , l, and t ∈ Tm−1.
10:
11:
if Tm is the ﬁrst neuron sub-group of layer m then
Broadcast values in (48) to partitions between layers m − 2 and m − 1
corresponding to the neuron sub-group Tm−1 at layer m − 1;
see the description after (38).
end if
12:
13: end if
66
Algorithm 3 A distributed subsampled Hessian Newton method with variable partition.
1: Given  ∈ (0, 1), λ1, σ ∈ (0, 1), η ∈ (0, 1), CGmax, CGmin, and r ∈ (0, 100].
2: Let p be the index of the current partition and generate the initial local model vector
p.
θ1
3: Compute f (θ1).
4: for k = 1, . . . , do
5:
Choose a set Sk ⊂ {1, . . . , l}.
p,∀i ∈ Sk.
Compute gk
Approximately solve the linear system in (60) by CG to obtain a direction dk
after
p and J i
end while
Update λk+1 based on (66).
24:
25: end for
67
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
|Sk|(cid:88)
I +
|Sk|
p ≥ CGmax or
i=1
is satisﬁed or #CGk
||(λkI +
(J i
p)T BiJ i
p)dk
p + gk
p|| ≤ σ||gk
p||
{# partitions ﬁnished ≥ r% × P and #CGk
p ≥ CGmin},
p is the number of CG iterations that have been run so far.
p = β1dk
p + β2dk−1
by solving (61).
where #CGk
Derive dk
αk = 1.
while true do
p = θk
Update θk+1
if Tm and Tm−1 are the ﬁrst neuron subgroups at layers L and L− 1, respec-
p and then compute f (θk+1).
p + αkdk
tively, then
if (65) is satisﬁed then
Notify all partitions to stop.
end if
else
Wait for the notiﬁcation to stop.
end if
if the stop notiﬁcation has been received then
break;
end if
αk = αk/2.
Algorithm 4 Standard stochastic gradient methods
1: Given a learning rate η.
2: for k = 0, . . . do
3:
Choose ik ∈ {1, . . . , l}.
θk+1 = θk − η∇f ik(θk).
4:
5: end for
Algorithm 5 Mini-batch stochastic gradient methods in Theano/Pylearn2 (Goodfellow
et al., 2013).
1: Given epoch = 0, min epochs = 200, a learning rate η, a minimum learning rate
ηmin = 10−6, α = 0, r = 0, X = 10−5, N = 10, a batch size b = |Sk| = 100,
an initial momentum m0 = 0.9, a ﬁnal momentum mf = 0.99, an exponentially
decay factor γ = 1.0000002, and an updating vector v ← 0.
2: counter ← N.
3: lowest value ← ∞.
4: while epoch < min epochs or counter > 0 do
5:
Split the whole training data into K disjoint subsets, Sk, k = 1, . . . , K.
α ← min(epoch/min epochs, 1.0).
m ← (1 − α)m0 + αmf.
for k = 1, . . . , K do
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
v ← mv − max(η/γr, ηmin)∇f Sk(θ).
θ ← θ + v.
r ← r + 1.
end for
epoch ← epoch + 1.
Calculate the function value h of the validation set.
if (h < (1 − X)× lowest value) then
counter ← N.
else
counter ← counter − 1.
end if
lowest value ← min(lowest value, h).
20:
21: end while
68
(a) SensIT Vehicle
(b) poker
(c) MNIST
(d) Letter
69
 70 72 74 76 78 80 82 84 86 0 5 10 15 20 25 30 35 40Testing Accuracy (%)Iterationssubsampled-GNdiagdiag + sync 50%diag + sync 25% 70 72 74 76 78 80 82 84 86 0 500 1000 1500 2000Testing Accuracy (%)Training time in secondssubsampled-GNdiagdiag + sync 50%diag + sync 25% 0 20 40 60 80 100 0 5 10 15 20 25 30 35 40Testing Accuracy (%)Iterationssubsampled-GNdiagdiag + sync 50%diag + sync 25% 0 20 40 60 80 100 0 500 1000 1500 2000Testing Accuracy (%)Training time in secondssubsampled-GNdiagdiag + sync 50%diag + sync 25% 80 85 90 95 100 0 5 10 15 20 25 30 35 40Testing Accuracy (%)Iterationssubsampled-GNdiagdiag + sync 50%diag + sync 25% 80 85 90 95 100 0 5000 10000 15000 20000Testing Accuracy (%)Training time in secondssubsampled-GNdiagdiag + sync 50%diag + sync 25% 0 20 40 60 80 100 0 5 10 15 20 25 30 35 40Testing Accuracy (%)Iterationssubsampled-GNdiagdiag + sync 50%diag + sync 25% 0 20 40 60 80 100 0 1000 2000 3000 4000 5000 6000Testing Accuracy (%)Training time in secondssubsampled-GNdiagdiag + sync 50%diag + sync 25%(e) USPS
(f) Pendigits
(g) Sensorless
(h) Satimage
Figure 4: A comparison of different techniques to implement distributed Newton meth-
ods. Left: testing accuracy versus number of iterations. Right: testing accuracy versus
training time.
70
 0 20 40 60 80 100 0 5 10 15 20Testing Accuracy (%)Iterationssubsampled-GNdiagdiag + sync 50%diag + sync 25% 0 20 40 60 80 100 0 20 40 60 80 100 120Testing Accuracy (%)Training time in secondssubsampled-GNdiagdiag + sync 50%diag + sync 25% 0 20 40 60 80 100 0 5 10 15 20Testing Accuracy (%)Iterationssubsampled-GNdiagdiag + sync 50%diag + sync 25% 0 20 40 60 80 100 0 20 40 60 80 100 120 140Testing Accuracy (%)Training time in secondssubsampled-GNdiagdiag + sync 50%diag + sync 25% 0 20 40 60 80 100 0 5 10 15 20 25 30 35 40Testing Accuracy (%)Iterationssubsampled-GNdiagdiag + sync 50%diag + sync 25% 0 20 40 60 80 100 0 1000 2000 3000 4000 5000 6000 7000 8000Testing Accuracy (%)Training time in secondssubsampled-GNdiagdiag + sync 50%diag + sync 25% 0 20 40 60 80 100 0 5 10 15 20 25 30Testing Accuracy (%)Iterationssubsampled-GNdiagdiag + sync 50%diag + sync 25% 0 20 40 60 80 100 0 50 100 150 200 250 300 350Testing Accuracy (%)Training time in secondssubsampled-GNdiagdiag + sync 50%diag + sync 25%(a) Dense initialization.
(b) Sparse initialization.
Figure 5: A comparison between SG and Newton. A 28-300-300-1 network is applied
to train HIGGS. SG-x means that the initial learning rate x is used. For Newton, each
iteration means that we go through line 5 to line 24 in Algorithm 3, while for SG, each
iteration means that we go through the whole training data once. The curve of SG-0.03
in the dense initialization is not presented because the AUC value never exceeds 0.5.
Left: AUC versus number of iterations. Right: AUC versus training time in seconds
(log-scaled).
71
 0.75 0.78 0.81 0.84 0.87 0 100 200 300 400 500AUCIterationsdiag + sync 50%SG-0.02SG-0.01SG-0.005SG-0.001 0.75 0.78 0.81 0.84 0.87 100 1000 10000 100000AUCTraining time in seconds (log-scaled)diag + sync 50%SG-0.02SG-0.01SG-0.005SG-0.001 0.75 0.78 0.81 0.84 0.87 0 100 200 300 400 500AUCIterationsdiag + sync 50%SG-0.03SG-0.02SG-0.01SG-0.005SG-0.001 0.75 0.78 0.81 0.84 0.87 100 1000 10000 100000AUCTraining time in seconds (log-scaled)diag + sync 50%SG-0.03SG-0.02SG-0.01SG-0.005SG-0.001
